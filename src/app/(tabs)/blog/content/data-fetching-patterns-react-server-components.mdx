import {
  RequestWaterfallDemo,
  CacheDeduplicationDemo,
  CSRWaterfallDemo,
  SSRWaterfallDemo,
} from "../[slug]/components/data-fetching-patterns";

As developers, what we are optimizing for is basically <Highlight>how fast we can show meaningful content to the end
user</Highlight>, at an optimal infra cost. When the final UI depends on some data from an external source, how we fetch
that data has a direct impact on how soon we are showing the final UI to the user.

For the last decade, we have treated data fetching as a specific "moment in time."

## The Client-Side Data Fetching Model

The pattern that we follow is that we mount a React component and render a pending state on UI, and then `useEffect`
fires, which fetches data from our external source. Once we get data from the external source, we render the final UI.

What we notice here is that there is a request waterfall. The browser first needs to get the required JavaScript to
render that component from the server. Then it has to make another request to the server to get the data required to
render the UI. Only after that can it render the final UI on the user's screen.

<CSRWaterfallDemo />

## Traditional Server-Side Rendering: Moving Data Earlier

This was later improved with the server-side rendering technique. Now, when the initial document request comes to the
server, you fetch the data even before React starts parsing the components on the server to generate the HTML.

You pass this fetched data via props to the root component, and now it is your job to push that data down from your root
React component to the target component where you actually need it. So when React starts parsing this component tree to
create HTML, it already has the data required to render that component.

Now, on the initial HTML request, the server sends a full-blown piece of final **meaningful UI** to the end user in a
single request. There are no more round trips to the server to render the final expected UI. All things are done in the
single request itself.

<SSRWaterfallDemo />

### The Tradeoffs of Server-Side Rendering

But this approach had its own downsides.

#### 1. Data Must Be Hoisted and Passed Down

You always have to fetch data outside the React tree on the server and pass it down as props to the root React
component. Now imagine if the component where you require this data is very deep down in the tree. You always have to
pass this data via props only\*.

#### 2. Hydration and Payload Costs

Surely, the prop-drilling part can be solved by using the Context API, where you keep a React context in the root
component and wrap it in a context provider. Now you can read the context value at any depth.

But the problem is that the data we pass as props to our root React component on the server to generate the HTML string
also needs to be passed to the browser. React needs this data to hydrate the HTML string on the client, and it
re-renders the same JavaScript on the client that it earlier used to build the component tree on the server.

Now imagine if the data that we fetched on the server is quite big. This will bloat the JavaScript that we end up
sending to the client. Even though the component where you are using this data is a dumb component and is just rendering
stuff with no interactivity, React will still re-render it again in the browser, and for rendering it needs that
payload. <Highlight>Basically, there is no way of rendering a component exclusively on the server through which we can
avoid this hydration and payload cost.</Highlight>

## Why React Server Components Exist

So what if there could be a way to fetch data close to the component where it is actually needed, and also skip the
hydration part on the client for components where no client interactivity is required by exclusively rendering these
components just once on the server only.

This can be achieved with **React Server Components**.

<RequestWaterfallDemo />

In the next section, we’ll look at the most common data-fetching patterns that one can use in their app with React
Server Components.

## Data Fetching and Sharing Patterns in React Server Components

I’ll categorize these patterns into two main sections.

The first category focuses on scenarios where you fetch data in a Server Component and need to share that data only
across other Server Components in the tree.

In the second category, we’ll look at cases where data is fetched in a Server Component but needs to be shared with
Client Components. This can also be combined with the first category, where the same data is fetched in a Server
Component and shared across both Server Components and Client Components.

I won’t cover patterns where data is fetched in a Client Component and shared across other Client Components, since that
area is already well covered in many places online.

### 1. Server-Owned Data (No Client State)

Let’s say we are building an app where we have to fetch a user’s preferences from an API and use that data across
multiple server components.

#### Data Needed Across Server Components

The good thing about Server Components is that, unlike normal React components, they run exclusively on the server. We
are sure that during the entire lifecycle of a request, a Server Component will only run once, and these components can
be async in nature.

As a result, we can directly call the data-fetching logic in the nearest Server Component where we actually need the
data to render the UI.

```jsx
async function ProductCard() {
  const userPreferences = await getUserPreferences();

  return (
    <Card>
      <Discount>{userPreferences?.maxDiscount}</Discount>
    </Card>
  );
}
```

It doesn’t matter how deep this ProductCard component is in the React tree. But what if we call this component multiple
times at different levels of the React tree, as shown below? Would there be duplicate fetch calls?

```jsx
async function Page() {
  return (
    <Layout>
      {table.map((item) => (
        <ProductCard key={item.key} />
      ))}
      <Footer>
        <ProductCard />
        <ProductCard />
      </Footer>
    </Layout>
  );
}
```

There are a few optimizations when it comes to data fetching in Server Components.

##### Fetch De-duplication

If you're using Next.js, it extends the native `fetch` API to automatically dedupe identical requests within a single
render pass. So if multiple Server Components call the same fetch, only one network request actually goes out.

Interestingly, React itself used to do this. The original implementation patched the global `fetch` to use `React.cache`
under the hood. But in April 2024, the React team [removed this behavior](https://github.com/facebook/react/pull/28896)
after some RSC framework maintainers pushed back on it. Now it's up to frameworks like Next.js to reimplement it in
userspace.

For this deduplication to kick in, the request must be truly identical — same URL, same headers, same config. In
real-world apps, this is often not the case.

For example, many applications use a wrapper around `fetch` where default headers are added, such as an `x-request-id`
with a unique value for every call. In some cases, the data might not even come from a `fetch` call at all, but directly
from a database.

```typescript
async function client(endpoint: string, options: RequestConfig = {}) {
  const headers = makeHeaders(options.headers, { "x-request-id": generateUUID() });
  const config = makeConfig(options, { headers });
  return fetch(endpoint, config);
}

async function getUserPreferences() {
  const response = await client("https://api.gauravthakur.com/v1/user-config");
  return response.json();
}

async function getOrderStatus(id: string) {
  const order = await prisma.order.findFirst({
    where: { id },
  });
  return order?.status ?? null;
}
```

With this logic, if you use `getUserPreferences` or `getOrderStatus` at multiple places, the automatic deduplication
won't help you. Each call to `getUserPreferences` produces a unique fetch because the headers are different, and
`getOrderStatus` is custom logic that doesn't go through `fetch` at all.

##### Custom Logic De-duplication

To handle situations where we need to de-duplicate custom logic, React has introduced a `cache` API.

To make sure that a function is called only once per request cycle, we can wrap it with the `cache` function provided by
React. With this change, our logic would look like this:

```typescript
import { cache } from "react";

const getUserPreferences = cache(async () => {
  const response = await client("https://api.gauravthakur.com/v1/user-config");
  return response.json();
});

const getOrderStatus = cache(async (id: string) => {
  const order = await prisma.order.findFirst({
    where: { id },
  });
  return order?.status ?? null;
});
```

Now, no matter how many times we call these functions at different levels in Server Components, they will only be called
once during a single render cycle.

<CacheDeduplicationDemo />

### 2. Shared Data (Crossing the Server–Client Boundary)

When a piece of data is needed inside a client boundary, the simplest thing to try first is to pass it down as a prop
from the nearest server component.

One important caveat here is that we should be extra cautious when passing props from a server component to a client
component. Any data that crosses this boundary needs to be serialized and sent to the browser along with the JavaScript
for that client component.

React needs this data during hydration so that it can re-render the same component tree on the client. As a result,
large or unnecessary props can directly increase the payload size and the amount of work done during hydration.

```jsx
// server component (nearest place where we can fetch)
export default async function Page() {
  const prefs = await getUserPreferences();
  return <ClientSettingsPanel initialPrefs={prefs} />;
}

// client component
function ClientSettingsPanel({ initialPrefs }) {
  // use initialPrefs directly
}
```

If the client boundary is very deep and there's no server component nearby, or you need this data throughout the app,
use `Context` to provide the value instead of prop-drilling. Context is straightforward to implement and great for
read-only values that won't change during the session.

```jsx
// server component
export default async function Page() {
  const prefs = await getUserPreferences();
  return (
    <PrefsProvider value={prefs}>
      <DeepTree />
    </PrefsProvider>
  );
}

// client (deep)
function SomeDeepClientComponent() {
  const prefs = usePrefs();
}
```

If the data can change over time after sending it to the client, you still have two broad options to refresh the stale
UI:

#### 1. Server as the source of truth

You can keep the server as the source of truth and invoke a server action to update the data. Once the action completes,
you revalidate the client cache using your framework’s invalidation APIs (for example, `revalidatePath` or
`router.refresh` in Next.js). This keeps the update flow consistent.

#### 2. Client-managed refresh using a client cache

If you want to avoid a full backend refresh and instead want the client to fetch updated data by itself, you can use a
client cache like React Query instead of raw Context.

In this approach, you pass the server-fetched value as initialData and provide a fetcher for subsequent updates.

```jsx
// server component: pass initial data
export default async function Page() {
  const prefs = await getUserPreferences();
  return <ClientSettingsPanel initialPrefs={prefs} />;
}

// client component using react-query
function ClientSettingsPanel({ initialPrefs }) {
  const { data } = useQuery({
    queryKey: ["user-prefs"],
    queryFn: async () => {
      const response = await fetch("/api/user-prefs");
      return response.json();
    },
    initialData: initialPrefs,
  });
  console.log(data);
}
```

This pattern works if the data is read in one place only, and you want a client side refetching or mutation. In these
situations, initialData gives you a smooth transition from server-rendered data to client-managed state.

One thing to note is that if useQuery is called in a component deeper down the tree, you need to pass the same
initialData all the way down to that point. A better solution would be to use

##### Query hydration: the more scalable pattern

In most real-world cases, where data can be required at any depth in the tree or in multiple client components, query
hydration is a much more practical approach.

With hydration, you prefetch the data on the server, dehydrate the query cache, and then rehydrate it on the client.
This way, all client components using the same query can access the data immediately, without manually passing
initialData around.

Below is a simplified example using the latest React Query SSR pattern.

```tsx
// app/dashboard/page.tsx
import { dehydrate, HydrationBoundary, QueryClient } from "@tanstack/react-query";
import Dashboard from "./dashboard";
import { getUserPreferences } from "./api";

export default async function DashboardPage() {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Dashboard />
    </HydrationBoundary>
  );
}
```

Here, we fetch the data on the server and dehydrate the query cache. At this point, the server is done — no props, no
initialData, no prop drilling.

```tsx
// app/dashboard/dashboard.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { getUserPreferences } from "./api";

export default function Dashboard() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return (
    <>
      <Header />
      <SettingsPanel />
    </>
  );
}

function Header() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return <span>Max Discount: {preferences?.maxDiscount}</span>;
}

function SettingsPanel() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return <div>{/* render preferences */}</div>;
}
```

With this setup:

1. Data prefetched on the server is available immediately on the client
2. useQuery can be called at any depth
3. Multiple components can safely read the same query
4. Client-only queries and server-prefetched queries can coexist

This pattern scales much better as the application grows and avoids the DX issues of passing initialData manually.

#### Streaming promises: pass the Promise, don’t await it

One thing that often gets missed is that you don’t always have to await data on the server before sending HTML to the
client.

In JavaScript, promises are eager. The moment you call an async function, the work starts. You can use this to your
advantage by starting the fetch on the server, passing the promise to a client component, and letting the client wait
for it instead of the server. This can help you avoid waterfalls and start network work as early as possible.

```tsx
// app/page.tsx (server)
import { Suspense } from "react";
import PageWrapper from "./page-wrapper";
import ClientPanel from "./client-panel";
import { getUserPreferences } from "./api";

export default function Page() {
  // start the fetch early — do not await
  const prefsPromise = getUserPreferences();

  return (
    <PageWrapper>
      <Suspense fallback={<div>Loading preferences...</div>}>
        <ClientPanel prefsPromise={prefsPromise} />
      </Suspense>
    </PageWrapper>
  );
}
```

```tsx
// app/client-panel.tsx
"use client";
import { use } from "react";

export default function ClientPanel({ prefsPromise }) {
  const prefs = use(prefsPromise);
  return <div>Max discount: {prefs.maxDiscount}</div>;
}
```

One important constraint to keep in mind is that the promise must resolve to serializable data. Since this data is
streamed from the server to the browser, it needs to be JSON-compatible.

Returning class instances, database documents (for example, a Mongoose document), or values with methods will break this
pattern. The promise should resolve to plain objects, arrays, or primitives.

What matters here is where the fetch is initiated. By starting the request at the page level, the network work begins
while React is still rendering the rest of the tree. If the same fetch were awaited inside a deeply nested component, it
would only start once React reaches that part of the tree, creating a render-time waterfall.

The client does not make a second request. The resolved data is streamed to the browser over the same response, and the
Suspense boundary is replaced once the promise resolves.

This pattern is useful when:

- the data is needed inside a client component
- the fetch is slow or expensive
- the component consuming the data sits deep in the tree
- you want to avoid blocking the server render on that fetch

This doesn’t replace hydration or client caching. It’s simply a way to start work earlier and move waiting time out of
the server render path when crossing the server–client boundary.

## Conclusion

We started with a simple goal: show meaningful content to users as fast as possible, while keeping infra costs sane. The
arrival of Server Components shifts the problem from “when do I fetch?” to “where should data live, who owns it, and how
does it move across the server–client boundary?”

Once you start looking at data flow through that lens, the tradeoffs become much clearer.

A quick recap of the patterns we covered:

1. Server-owned data — fetch data close to the consuming Server Component. When the same data is needed multiple times
   during a single render, use request-scoped deduplication (cache) to avoid repeated work.

2. Client-owned data — keep data on the client when it is session-scoped or frequently changing. Local state, Context,
   or a client cache works well here, depending on how widely the data is shared.

3. Shared data (crossing the boundary) — start by passing data as props from the nearest Server Component. Use Context
   for simple, read-only values that are needed deep in the tree. When the server should remain authoritative, use
   server actions and revalidation. When the client needs to control refreshes, use a client cache, and prefer query
   hydration over initialData once the same data is consumed in multiple places.

4. Streaming data to the client — when data is slow and consumed by a client component, you can start the fetch early on
   the server and pass the promise across the boundary. This avoids render-time waterfalls by letting the server keep
   rendering while the client waits behind a Suspense boundary.

None of these patterns are universally correct. Each one optimizes for a different constraint: ownership, freshness,
payload size, or render timing. Framework APIs will continue to evolve, but these constraints won’t. If you design
around them, the specific tools tend to fall into place naturally.

export const metadata = {
  title: "Data Fetching Patterns in React Server Components",
  createdAt: "January 5, 2026",
  description:
    "A practical guide to data fetching in React Server Components. Learn when to fetch on the server vs client, how to dedupe requests with React's cache API, and patterns for sharing data across the server-client boundary using props, context, and React Query hydration.",
  metaDescription: "Learn about the most common data fetching patterns in React Server Components",
};
