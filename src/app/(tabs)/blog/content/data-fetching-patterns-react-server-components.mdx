import {
  RequestWaterfallDemo,
  CacheDeduplicationDemo,
  CSRWaterfallDemo,
  SSRWaterfallDemo,
} from "../[slug]/components/data-fetching-patterns";

As developers, what we are optimizing for is basically <Highlight>how fast we can show meaningful content to the end
user</Highlight>, at an optimal infra cost. When the final UI depends on some data from an external source, how we fetch
that data has a direct impact on how soon we are showing the final UI to the user.

For the last decade, we have treated data fetching as a specific "moment in time."

## The Client-Side Data Fetching Model

The pattern that we follow is that we mount a React component and render a pending state on UI, and then `useEffect`
fires, which fetches data from our external source. Once we get data from the external source, we render the final UI.

What we notice here is that there is a request waterfall. The browser first needs to get the required JavaScript to
render that component from the server. Then it has to make another request to the server to get the data required to
render the UI. Only after that can it render the final UI on the user's screen.

<CSRWaterfallDemo />

## Traditional Server-Side Rendering: Moving Data Earlier

This was later improved with the server-side rendering technique. Now, when the initial document request comes to the
server, you fetch the data even before React starts parsing the components on the server to generate the HTML.

You pass this fetched data via props to the root component, and now it is your job to push that data down from your root
React component to the target component where you actually need it. So when React starts parsing this component tree to
create HTML, it already has the data required to render that component.

Now, on the initial HTML request, the server sends a full-blown piece of final **meaningful UI** to the end user in a
single request. There are no more round trips to the server to render the final expected UI. All things are done in the
single request itself.

<SSRWaterfallDemo />

### The Tradeoffs of Server-Side Rendering

But this approach had its own downsides.

#### 1. Data Must Be Hoisted and Passed Down

You always have to fetch data outside the React tree on the server and pass it down as props to the root React
component. Now imagine if the component where you require this data is very deep down in the tree. You always have to
pass this data via props only\*.

#### 2. Hydration and Payload Costs

Surely, the prop-drilling part can be solved by using the Context API, where you keep a React context in the root
component and wrap it in a context provider. Now you can read the context value at any depth.

But the problem is that the data we pass as props to our root React component on the server to generate the HTML string
also needs to be passed to the browser. React needs this data to hydrate the HTML string on the client, and it
re-renders the same JavaScript on the client that it earlier used to build the component tree on the server.

Now imagine if the data that we fetched on the server is quite big. This will bloat the JavaScript that we end up
sending to the client. Even though the component where you are using this data is a dumb component and is just rendering
stuff with no interactivity, React will still re-render it again in the browser, and for rendering it needs that
payload. <Highlight>Basically, there is no way of rendering a component exclusively on the server through which we can
avoid this hydration and payload cost.</Highlight>

## Why React Server Components Exist

So what if there could be a way to fetch data close to the component where it is actually needed, and also skip the
hydration part on the client for components where no client interactivity is required by exclusively rendering these
components just once on the server only.

This can be achieved with **React Server Components**.

<RequestWaterfallDemo />

In the next section, we’ll look at the most common data-fetching patterns that one can use in their app with React
Server Components.

## Data Fetching and Sharing Patterns in React Server Components

### 1. Server-Owned Data (No Client State)

Let’s say we are building an app where we have to fetch a user’s preferences from an API and use that data across
multiple server components.

#### Data Needed Across Server Components

The good thing about Server Components is that, unlike normal React components, they run exclusively on the server. We
are sure that during the entire lifecycle of a request, a Server Component will only run once, and these components can
be async in nature.

As a result, we can directly call the data-fetching logic in the nearest Server Component where we actually need the
data to render the UI.

```jsx
async function ProductCard() {
  const userPreferences = await getUserPreferences();

  return (
    <Card>
      <Discount>{userPreferences?.maxDiscount}</Discount>
    </Card>
  );
}
```

It doesn’t matter how deep this ProductCard component is in the React tree. But what if we call this component multiple
times at different levels of the React tree, as shown below? Would there be duplicate fetch calls?

```jsx
async function Page() {
  return (
    <Layout>
      {table.map((item) => (
        <ProductCard key={item.key} />
      ))}
      <Footer>
        <ProductCard />
        <ProductCard />
      </Footer>
    </Layout>
  );
}
```

There are a few optimizations when it comes to data fetching in Server Components.

##### Fetch De-duplication

If you're using Next.js, it extends the native `fetch` API to automatically dedupe identical requests within a single
render pass. So if multiple Server Components call the same fetch, only one network request actually goes out.

Interestingly, React itself used to do this. The original implementation patched the global `fetch` to use `React.cache`
under the hood. But in April 2024, the React team [removed this behavior](https://github.com/facebook/react/pull/28896)
after some RSC framework maintainers pushed back on it. Now it's up to frameworks like Next.js to reimplement it in
userspace.

For this deduplication to kick in, the request must be truly identical — same URL, same headers, same config. In
real-world apps, this is often not the case.

For example, many applications use a wrapper around `fetch` where default headers are added, such as an `x-request-id`
with a unique value for every call. In some cases, the data might not even come from a `fetch` call at all, but directly
from a database.

```typescript
async function client(endpoint: string, options: RequestConfig = {}) {
  const headers = makeHeaders(options.headers, { "x-request-id": generateUUID() });
  const config = makeConfig(options, { headers });
  return fetch(endpoint, config);
}

async function getUserPreferences() {
  const response = await client("https://api.gauravthakur.com/v1/user-config");
  return response.json();
}

async function getOrderStatus(id: string) {
  const order = await prisma.order.findFirst({
    where: { id },
  });
  return order?.status ?? null;
}
```

With this logic, if you use `getUserPreferences` or `getOrderStatus` at multiple places, the automatic deduplication
won't help you. Each call to `getUserPreferences` produces a unique fetch because the headers are different, and
`getOrderStatus` is custom logic that doesn't go through `fetch` at all.

##### Custom Logic De-duplication

To handle situations where we need to de-duplicate custom logic, React has introduced a `cache` API.

To make sure that a function is called only once per request cycle, we can wrap it with the `cache` function provided by
React. With this change, our logic would look like this:

```typescript
import { cache } from "react";

const getUserPreferences = cache(async () => {
  const response = await client("https://api.gauravthakur.com/v1/user-config");
  return response.json();
});

const getOrderStatus = cache(async (id: string) => {
  const order = await prisma.order.findFirst({
    where: { id },
  });
  return order?.status ?? null;
});
```

Now, no matter how many times we call these functions at different levels in Server Components, they will only be called
once during a single render cycle.

<CacheDeduplicationDemo />

### 2. Shared Data (Crossing the Server–Client Boundary)

When a piece of data is needed inside a client boundary, the simplest thing to try first is to pass it down as a prop
from the nearest server component.

One important caveat here is that we should be extra cautious when passing props from a server component to a client
component. Any data that crosses this boundary needs to be serialized and sent to the browser along with the JavaScript
for that client component.

React needs this data during hydration so that it can re-render the same component tree on the client. As a result,
large or unnecessary props can directly increase the payload size and the amount of work done during hydration.

```jsx
// server component (nearest place where we can fetch)
export default async function Page() {
  const prefs = await getUserPreferences();
  return <ClientSettingsPanel initialPrefs={prefs} />;
}

// client component
function ClientSettingsPanel({ initialPrefs }) {
  // use initialPrefs directly
}
```

If the client boundary is very deep and there's no server component nearby, or you need this data throughout the app,
use Context to provide the value instead of prop-drilling. Context is simple to implement and great for read-only values
that won't change during the session.

```jsx
// server component
export default async function Page() {
  const prefs = await getUserPreferences();
  return (
    <PrefsProvider value={prefs}>
      <DeepTree />
    </PrefsProvider>
  );
}

// client (deep)
function SomeDeepClientComponent() {
  const prefs = usePrefs();
}
```

If the data can change over time after sending it to the client, you still have two broad options to refresh the stale
UI:

#### 1. Server as the source of truth

You can keep the server as the source of truth and invoke a server action to update the data. Once the action completes,
you revalidate the client cache using your framework’s invalidation APIs (for example, `revalidatePath` or
`router.refresh` in Next.js). This keeps the update flow consistent.

#### 2. Client-managed refresh using a client cache

If you want to avoid a full backend refresh and instead want the client to fetch updated data by itself, you can use a
client cache like React Query instead of raw Context.

In this approach, you pass the server-fetched value as initialData and provide a fetcher for subsequent updates.

```jsx
// server component: pass initial data
export default async function Page() {
  const prefs = await getUserPreferences();
  return <ClientSettingsPanel initialPrefs={prefs} />;
}

// client component using react-query
function ClientSettingsPanel({ initialPrefs }) {
  const { data } = useQuery({
    queryKey: ["user-prefs"],
    queryFn: async () => {
      const response = await fetch("/api/user-prefs");
      return response.json();
    },
    initialData: initialPrefs,
  });
  console.log(data);
}
```

This pattern works if the data is read in one place only, and you want a client side refetching or mutation. In these
situations, initialData gives you a smooth transition from server-rendered data to client-managed state.

One thing to note is that if useQuery is called in a component deeper down the tree, you need to pass the same
initialData all the way down to that point. A better solution would be to use

##### Query hydration: the more scalable pattern

In most real-world cases, where data can be required at any depth in the tree or in multiple client components, query
hydration is a much more practical approach.

With hydration, you prefetch the data on the server, dehydrate the query cache, and then rehydrate it on the client.
This way, all client components using the same query can access the data immediately, without manually passing
initialData around.

Below is a simplified example using the latest React Query SSR pattern.

```tsx
// app/dashboard/page.tsx
import { dehydrate, HydrationBoundary, QueryClient } from "@tanstack/react-query";
import Dashboard from "./dashboard";
import { getUserPreferences } from "./api";

export default async function DashboardPage() {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Dashboard />
    </HydrationBoundary>
  );
}
```

Here, we fetch the data on the server and dehydrate the query cache. At this point, the server is done — no props, no
initialData, no prop drilling.

```tsx
// app/dashboard/dashboard.tsx
"use client";

import { useQuery } from "@tanstack/react-query";
import { getUserPreferences } from "./api";

export default function Dashboard() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return (
    <>
      <Header />
      <SettingsPanel />
    </>
  );
}

function Header() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return <span>Max Discount: {preferences?.maxDiscount}</span>;
}

function SettingsPanel() {
  const { data: preferences } = useQuery({
    queryKey: ["user-preferences"],
    queryFn: getUserPreferences,
  });

  return <div>{/* render preferences */}</div>;
}
```

With this setup:

1. Data prefetched on the server is available immediately on the client
2. useQuery can be called at any depth
3. Multiple components can safely read the same query
4. Client-only queries and server-prefetched queries can coexist

This pattern scales much better as the application grows and avoids the DX issues of passing initialData manually.

## Conclusion

We started with a simple goal, showing meaningful content to users as fast as possible while keeping infra costs sane.
The arrival of Server Components changes the problem from “when do I fetch?” to “where should data live, who owns it,
and how do we move it across the server–client boundary?”

Quick recap of the patterns we covered:

1. Server-owned data — fetch near the consuming server component; use `cache` to dedupe custom logic when the same data
   is needed multiple times in a single render.
2. Client-owned data — local state, context, or a client cache when the data is session-scoped or mutable in the
   browser.
3. Shared data (crossing the boundary) — prefer props from the nearest server component; fallback to Context for simple,
   read-only values at depth; use server actions + revalidation when the server should remain authoritative; use a
   client cache (React Query) when you want the client to manage refreshes without a full backend revalidation, and
   prefer hydration over `initialData` when the same query is used in many places.

export const metadata = {
  title: "Data Fetching Patterns in React Server Components",
  createdAt: "January 5, 2026",
  description:
    "A practical guide to data fetching in React Server Components. Learn when to fetch on the server vs client, how to dedupe requests with React's cache API, and patterns for sharing data across the server-client boundary using props, context, and React Query hydration.",
  metaDescription: "Learn about the most common data fetching patterns in React Server Components",
};
